name: Deploy to Kubernetes

on:
  workflow_call:
    inputs:
      event-service-changed:
        required: false
        type: boolean
        default: false
      booking-service-changed:
        required: false
        type: boolean
        default: false
      payment-service-changed:
        required: false
        type: boolean
        default: false
      frontend-changed:
        required: false
        type: boolean
        default: false
      gateway-changed:
        required: false
        type: boolean
        default: false
      user-service-changed:
        required: false
        type: boolean
        default: false
      image-tag:
        required: true
        type: string
    secrets:
      KUBECONFIG:
        required: false
      AWS_ACCESS_KEY_ID:
        required: false
      AWS_SECRET_ACCESS_KEY:
        required: false
      AWS_REGION:
        required: false
      EKS_CLUSTER_NAME:
        required: false
      EVENT_DB_URL:
        required: false
      BOOKING_DB_URL:
        required: false
      USER_DB_URL:
        required: false

concurrency:
  group: deploy-${{ github.ref }}
  cancel-in-progress: true

env:
  REGISTRY: ghcr.io
  IMAGE_PREFIX: ${{ github.repository_owner }}/ticketing

jobs:
  determine-environment:
    runs-on: ubuntu-latest
    outputs:
      namespace: ${{ steps.env.outputs.namespace }}
      environment: ${{ steps.env.outputs.environment }}
      use-eks: ${{ steps.env.outputs.use-eks }}
    steps:
      - name: Determine environment from branch
        id: env
        run: |
          BRANCH_NAME=${GITHUB_REF#refs/heads/}
          if [ "$BRANCH_NAME" = "main" ]; then
            echo "namespace=ticketing-prod" >> $GITHUB_OUTPUT
            echo "environment=production" >> $GITHUB_OUTPUT
            echo "use-eks=false" >> $GITHUB_OUTPUT
          elif [ "$BRANCH_NAME" = "release" ]; then
            echo "namespace=ticketing-staging" >> $GITHUB_OUTPUT
            echo "environment=staging" >> $GITHUB_OUTPUT
            echo "use-eks=false" >> $GITHUB_OUTPUT
          elif [ "$BRANCH_NAME" = "development" ]; then
            echo "namespace=ticketing-dev" >> $GITHUB_OUTPUT
            echo "environment=development" >> $GITHUB_OUTPUT
            echo "use-eks=true" >> $GITHUB_OUTPUT
          else
            echo "namespace=ticketing-dev" >> $GITHUB_OUTPUT
            echo "environment=development" >> $GITHUB_OUTPUT
            echo "use-eks=false" >> $GITHUB_OUTPUT
          fi
          echo "Deploying to namespace: $(cat $GITHUB_OUTPUT | grep namespace | cut -d'=' -f2)"
          echo "Using EKS: $(cat $GITHUB_OUTPUT | grep use-eks | cut -d'=' -f2)"
  
  prisma-migrations:
    needs: determine-environment
    if: inputs.event-service-changed || inputs.booking-service-changed || inputs.user-service-changed
    runs-on: ubuntu-latest
    environment: ${{ needs.determine-environment.outputs.environment }}
    steps:
      - uses: actions/checkout@v4
      
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
      
      - name: Run EventService migrations
        if: inputs.event-service-changed
        uses: ./.github/actions/run-prisma-migrations
        with:
          service-path: EventService
          database-url: ${{ secrets.EVENT_DB_URL }}
          namespace: ${{ needs.determine-environment.outputs.namespace }}
      
      - name: Run BookingService migrations
        if: inputs.booking-service-changed
        uses: ./.github/actions/run-prisma-migrations
        with:
          service-path: BookingService
          database-url: ${{ secrets.BOOKING_DB_URL }}
          namespace: ${{ needs.determine-environment.outputs.namespace }}
      
      - name: Run UserService migrations
        if: inputs.user-service-changed
        uses: ./.github/actions/run-prisma-migrations
        with:
          service-path: UserService
          database-url: ${{ secrets.USER_DB_URL }}
          namespace: ${{ needs.determine-environment.outputs.namespace }}

  deploy-k8s:
    needs: [determine-environment, prisma-migrations]
    if: always() && (needs.prisma-migrations.result == 'success' || needs.prisma-migrations.result == 'skipped')
    runs-on: ubuntu-latest
    environment: ${{ needs.determine-environment.outputs.environment }}
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up kubectl
        uses: azure/setup-kubectl@v4
      
      - name: Configure kubectl for EKS
        if: needs.determine-environment.outputs.use-eks == 'true'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}
      
      - name: Configure kubectl for EKS
        if: needs.determine-environment.outputs.use-eks == 'true'
        run: |
          aws eks update-kubeconfig --name ${{ secrets.EKS_CLUSTER_NAME }} --region ${{ secrets.AWS_REGION }}
          kubectl config set-context --current --namespace=${{ needs.determine-environment.outputs.namespace }} || true
      
      - name: Configure kubectl (static config)
        if: needs.determine-environment.outputs.use-eks != 'true'
        run: |
          mkdir -p $HOME/.kube
          echo "${{ secrets.KUBECONFIG }}" | base64 -d > $HOME/.kube/config
      
      - name: Set namespace context
        if: needs.determine-environment.outputs.use-eks != 'true'
        run: |
          NAMESPACE="${{ needs.determine-environment.outputs.namespace }}"
          echo "Deploying to namespace: $NAMESPACE"
          kubectl config set-context --current --namespace=$NAMESPACE || echo "Namespace $NAMESPACE may not exist yet"
      
      - name: Ensure namespace exists
        run: |
          NAMESPACE="${{ needs.determine-environment.outputs.namespace }}"
          kubectl create namespace $NAMESPACE --dry-run=client -o yaml | kubectl apply -f -
      
      - name: Update EventService
        if: inputs.event-service-changed
        run: |
          NAMESPACE="${{ needs.determine-environment.outputs.namespace }}"
          kubectl set image deployment/eventservice eventservice=${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-event:${{ inputs.image-tag }} -n $NAMESPACE
          kubectl rollout status deployment/eventservice --timeout=5m -n $NAMESPACE
      
      - name: Update BookingService
        if: inputs.booking-service-changed
        run: |
          NAMESPACE="${{ needs.determine-environment.outputs.namespace }}"
          kubectl set image deployment/bookingservice bookingservice=${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-booking:${{ inputs.image-tag }} -n $NAMESPACE
          kubectl rollout status deployment/bookingservice --timeout=5m -n $NAMESPACE
      
      - name: Update MockPaymentService
        if: inputs.payment-service-changed
        run: |
          NAMESPACE="${{ needs.determine-environment.outputs.namespace }}"
          kubectl set image deployment/mockpaymentservice mockpaymentservice=${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-payment:${{ inputs.image-tag }} -n $NAMESPACE
          kubectl rollout status deployment/mockpaymentservice --timeout=5m -n $NAMESPACE
      
      - name: Update Frontend
        if: inputs.frontend-changed
        run: |
          NAMESPACE="${{ needs.determine-environment.outputs.namespace }}"
          kubectl set image deployment/frontend frontend=${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-frontend:${{ inputs.image-tag }} -n $NAMESPACE
          kubectl rollout status deployment/frontend --timeout=5m -n $NAMESPACE
      
      - name: Update Gateway
        if: inputs.gateway-changed
        run: |
          NAMESPACE="${{ needs.determine-environment.outputs.namespace }}"
          kubectl set image deployment/gateway gateway=${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-gateway:${{ inputs.image-tag }} -n $NAMESPACE
          kubectl rollout status deployment/gateway --timeout=5m -n $NAMESPACE
      
      - name: Update UserService
        if: inputs.user-service-changed
        run: |
          NAMESPACE="${{ needs.determine-environment.outputs.namespace }}"
          kubectl set image deployment/userservice userservice=${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-user:${{ inputs.image-tag }} -n $NAMESPACE
          kubectl rollout status deployment/userservice --timeout=5m -n $NAMESPACE

  integration-tests:
    needs: [determine-environment, deploy-k8s]
    runs-on: ubuntu-latest
    environment: ${{ needs.determine-environment.outputs.environment }}
    steps:
      - uses: actions/checkout@v4
      
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
      
      - name: Install root dependencies
        run: npm ci
      
      - name: Set up kubectl
        uses: azure/setup-kubectl@v4
      
      - name: Configure kubectl for EKS
        if: needs.determine-environment.outputs.use-eks == 'true'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION || 'us-east-1' }}
      
      - name: Configure kubectl for EKS
        if: needs.determine-environment.outputs.use-eks == 'true'
        run: |
          aws eks update-kubeconfig --name ${{ secrets.EKS_CLUSTER_NAME }} --region ${{ secrets.AWS_REGION || 'us-east-1' }}
          kubectl config set-context --current --namespace=${{ needs.determine-environment.outputs.namespace }} || true
      
      - name: Configure kubectl (static config)
        if: needs.determine-environment.outputs.use-eks != 'true'
        run: |
          mkdir -p $HOME/.kube
          echo "${{ secrets.KUBECONFIG }}" | base64 -d > $HOME/.kube/config
      
      - name: Wait for services to be ready
        run: |
          NAMESPACE="${{ needs.determine-environment.outputs.namespace }}"
          echo "Waiting for all pods to be ready in namespace: $NAMESPACE"
          kubectl wait --for=condition=ready pod -l app=eventservice --timeout=5m -n $NAMESPACE || true
          kubectl wait --for=condition=ready pod -l app=booking --timeout=5m -n $NAMESPACE || true
          kubectl wait --for=condition=ready pod -l app=mockpaymentservice --timeout=5m -n $NAMESPACE || true
          kubectl wait --for=condition=ready pod -l app=gateway --timeout=5m -n $NAMESPACE || true
          kubectl get pods -n $NAMESPACE
      
      - name: Set up port forwarding
        run: |
          NAMESPACE="${{ needs.determine-environment.outputs.namespace }}"
          # Start port forwarding in background
          kubectl port-forward service/gateway 3000:3000 -n $NAMESPACE &
          kubectl port-forward service/eventservice 3001:3001 -n $NAMESPACE &
          kubectl port-forward service/bookingservice 3003:3003 -n $NAMESPACE &
          kubectl port-forward service/mockpaymentservice 3002:3002 -n $NAMESPACE &
          
          # Wait for port forwards to be ready
          sleep 10
          
          # Verify services are accessible
          curl -f http://localhost:3000/health || echo "Gateway not ready yet"
          curl -f http://localhost:3001/health || echo "EventService not ready yet"
          curl -f http://localhost:3003/health || echo "BookingService not ready yet"
          curl -f http://localhost:3002/health || echo "PaymentService not ready yet"
      
      - name: Run integration tests
        env:
          GATEWAY_URL: http://localhost:3000
          EVENT_SERVICE_URL: http://localhost:3001
          BOOKING_SERVICE_URL: http://localhost:3003
          PAYMENT_SERVICE_URL: http://localhost:3002
          ENVIRONMENT: ${{ needs.determine-environment.outputs.environment }}
        run: |
          npm run test:integration
      
      - name: Cleanup port forwarding
        if: always()
        run: |
          pkill -f "kubectl port-forward" || true

